{-# LANGUAGE OverloadedStrings #-}

module Amy.CPS.Convert
  ( convertCPSModule
  , convertCPSExpr
  ) where

import Data.Foldable (toList)
import Data.Maybe (mapMaybe)

import Amy.CPS.AST
import Amy.CPS.Monad
import Amy.Names
import Amy.Type
import Amy.TypeCheck.AST

convertCPSModule :: TModule -> CPSFix
convertCPSModule module' =
  let
    moduleNames = tModuleNames module'
    moduleIdentIds = identId <$> mapMaybe identName moduleNames
    maxId =
      if null moduleIdentIds
      then 0
      else maximum moduleIdentIds
  in runCPSConvert (maxId + 1) $ convertCPSModule' module'

convertCPSModule' :: TModule -> CPSConvert CPSFix
convertCPSModule' (TModule bindings _) =
  CPSFix
  <$> traverse convertBinding bindings
  <*> pure CPSHalt

convertCPSExpr :: TExpr -> (CPSVal -> CPSConvert CPSExpr) -> CPSConvert CPSExpr
convertCPSExpr (TELit lit) c = c (CPSLit lit)
convertCPSExpr (TEVar var) c = c (CPSVar (typedValue var))
-- TODO: Handle primops here. If the function is a primitive function, we can
-- just emit a PrimOp.
convertCPSExpr (TEApp (TApp funcExpr args _)) c = do
  returnName <- IdentName <$> freshIdent "r"
  returnVal <- IdentName <$> freshIdent "x"
  binding <- CPSFixBinding returnName [returnVal] <$> c (CPSVar returnVal)
  convertCPSExpr funcExpr $ \f ->
    convertCPSExprList (toList args) $ \argVars ->
      pure $ CPSEFix $ CPSFix [binding] $ CPSEApp $ CPSApp f (argVars ++ [CPSVar returnName])
convertCPSExpr (TELet (TLet bindings expr)) c = do
  bindings' <- traverse convertBinding bindings
  expr' <- convertCPSExpr expr c
  pure $ CPSEFix $ CPSFix bindings' expr'
convertCPSExpr (TEIf (TIf pred' then' else')) c =
  convertCPSExpr pred' $ \predVar -> do
    then'' <- convertCPSExpr then' c
    else'' <- convertCPSExpr else' c
    pure $ CPSEIf $ CPSIf predVar then'' else''

-- | Given a list of expressions, get the CPS values generated by CPS
-- converting them, collect them, and then apply to the given "continuation"
-- function.
convertCPSExprList :: [TExpr] -> ([CPSVal] -> CPSConvert CPSExpr) -> CPSConvert CPSExpr
convertCPSExprList es c = convertCPSExprList' es [] c

convertCPSExprList' :: [TExpr] -> [CPSVal] -> ([CPSVal] -> CPSConvert CPSExpr) -> CPSConvert CPSExpr
convertCPSExprList' [] vs c = c vs
convertCPSExprList' (e:es) vs c = convertCPSExpr e $ \v -> convertCPSExprList' es (v:vs) c

-- convertCPSExprList :: [TExpr] -> (CPSVal -> CPSExpr) -> ([ValueName], (CPSVal -> CPSExpr))--[(CPSVal, CPSExpr)]
-- convertCPSExprList exprs c = convertCPSExprList' exprs ([], c)

-- convertCPSExprList' :: [TExpr] -> ([ValueName], (CPSVal -> CPSExpr)) -> ([ValueName], (CPSVal -> CPSExpr))
-- convertCPSExprList' [] x = x
-- convertCPSExprList' (e:es) (names, c) =
--   let
--     genName = ValueName "FIXME" (NameIntId 0)
--   in convertCPSExprList' es (genName : names, \_ -> convertCPSExpr e c)

convertBinding :: TBinding -> CPSConvert CPSFixBinding
convertBinding (TBinding name _ args _ expr) = do
  contVar <- IdentName <$> freshIdent "k"
  let
    c' z = pure $ CPSEApp $ CPSApp (CPSVar contVar) [z]
  expr' <- convertCPSExpr expr c'
  pure $ CPSFixBinding name ((typedValue <$> args) ++ [contVar]) expr'
