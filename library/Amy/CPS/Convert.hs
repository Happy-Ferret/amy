{-# LANGUAGE OverloadedStrings #-}

module Amy.CPS.Convert
  ( convertCPSModule
  , convertCPSExpr
  ) where

import Data.Foldable (toList)

import Amy.CPS.AST
import Amy.Names
import Amy.Type
import Amy.TypeCheck.AST

convertCPSModule :: TModule -> CPSFix
convertCPSModule (TModule bindings _) =
  CPSFix (convertBinding <$> bindings) CPSHalt

convertCPSExpr :: TExpr -> (CPSVal -> CPSExpr) -> CPSExpr
convertCPSExpr (TELit lit) c = c (CPSLit lit)
convertCPSExpr (TEVar var) c = c (CPSVar (typedValue var))
-- TODO: Handle primops here. If the function is a primitive function, we can
-- just emit a PrimOp.
convertCPSExpr (TEApp (TApp funcExpr args _)) c =
  let
    returnName = ValueName "r" (NameIntId 0)
    returnVal = ValueName "x" (NameIntId 0)
  in
    CPSEFix $ CPSFix [CPSFixBinding returnName [returnVal] (c (CPSVar returnVal))] $
      convertCPSExpr funcExpr $ \f ->
      convertCPSExprList (toList args) $ \argVars ->
      CPSEApp $ CPSApp f (argVars ++ [CPSVar returnName])
convertCPSExpr (TELet (TLet bindings expr)) c = CPSEFix $ CPSFix (convertBinding <$> bindings) (convertCPSExpr expr c)
convertCPSExpr (TEIf (TIf pred' then' else')) c =
  convertCPSExpr pred' $ \predVar -> CPSEIf $ CPSIf predVar (convertCPSExpr then' c) (convertCPSExpr else' c)

-- | Given a list of expressions, get the CPS values generated by CPS
-- converting them, collect them, and then apply to the given "continuation"
-- function.
convertCPSExprList :: [TExpr] -> ([CPSVal] -> CPSExpr) -> CPSExpr
convertCPSExprList es c = convertCPSExprList' es [] c

convertCPSExprList' :: [TExpr] -> [CPSVal] -> ([CPSVal] -> CPSExpr) -> CPSExpr
convertCPSExprList' [] vs c = c vs
convertCPSExprList' (e:es) vs c = convertCPSExpr e $ \v -> convertCPSExprList' es (v:vs) c

-- convertCPSExprList :: [TExpr] -> (CPSVal -> CPSExpr) -> ([ValueName], (CPSVal -> CPSExpr))--[(CPSVal, CPSExpr)]
-- convertCPSExprList exprs c = convertCPSExprList' exprs ([], c)

-- convertCPSExprList' :: [TExpr] -> ([ValueName], (CPSVal -> CPSExpr)) -> ([ValueName], (CPSVal -> CPSExpr))
-- convertCPSExprList' [] x = x
-- convertCPSExprList' (e:es) (names, c) =
--   let
--     genName = ValueName "FIXME" (NameIntId 0)
--   in convertCPSExprList' es (genName : names, \_ -> convertCPSExpr e c)

convertBinding :: TBinding -> CPSFixBinding
convertBinding (TBinding name _ args _ expr) =
  CPSFixBinding name ((typedValue <$> args) ++ [contVar]) (convertCPSExpr expr c')
 where
  contVar = ValueName "k" (NameIntId 0)
  c' z = CPSEApp $ CPSApp (CPSVar contVar) [z]
